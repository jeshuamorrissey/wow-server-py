"""Utility methods for using SRP (see https://www.ietf.org/rfc/rfc2945.txt)."""
import hashlib
import itertools
import random
from typing import Tuple

import cryptography


###
# Utility functions.
###
def Random(n: int = 32) -> int:
    """Get a random number of a certain size.

    Args:
        n: The number of bytes in the random number.

    Returns:
        A random number which is `n` bytes long.
    """
    return random.SystemRandom().getrandbits(n * 8)


def HexToInt(hex_string: str, endian: str = 'big') -> int:
    """Convert the given hex string to an integer.

    Args:
        hex_string (str): the hex string to convert.
        endian (str): either 'big' or 'little' or big or little endian.

    Returns:
        int, `hex_string` converted to a number.
    """
    # Make sure the hex string is an even length (just add a 0 to the end).
    if len(hex_string) % 2 == 1:
        hex_string = '\x00' + hex_string
    return int.from_bytes(bytes(bytearray.fromhex(hex_string)), endian)


def IntToBytes(n: int) -> bytearray:
    """Convert the given number to a byte array.

    Args:
        n (int): the number to convert.

    Returns:
        bytearray, `n` as a bytearray.
    """
    n_hex = '{:x}'.format(n)

    # Add a 0 to the front to make sure the number is valid.
    if len(n_hex) % 2 == 1:
        n_hex = '0' + n_hex
    return bytearray.fromhex(n_hex)


def _H(*args) -> int:
    """Perform a hash of all of the arguments added together.

    Args:
        *args: a list of args to add to the hash.
        sep (str): a separator to put between each argument.

    Returns:
        int, a hash.
    """
    h = hashlib.sha1()
    for arg in args:
        if isinstance(arg, int):
            h.update(bytes(IntToBytes(arg)[::-1]))
        elif isinstance(arg, (bytes, bytearray)):
            h.update(arg)
        else:
            h.update(arg.encode())
    return HexToInt(h.hexdigest(), endian='little')


###
# SRP Constants.
###
# SRP Generator, this is the base of many of the equations used.
g = 7

# SRP Verifier Scale Factor, this is used to scale the verifier (which was
# stored in the database).
k = 3

# SRP Modulus. All operations are done in Base N. This is defined in the client.
N = 62100066509156017342069496140902949863249758336000796928566441170293728648119


###
# SRP Functions.
###
def GenerateVerifier(account_name: str, password: str, salt: int) -> int:
    """Generate the password verifier v."""
    x = _H(salt, _H(account_name.upper(), ':', password.upper()))
    return pow(g, x, N)


def GenerateEphemeral(v: int) -> Tuple[int, int]:
    """Generate a pair of ephemeral values (private/public, b/B).

    Args:
        v (int): the password verifier for the user.

    Returns:
        A private/public ephemeral.
    """
    b = Random(19)
    B = ((v * 3) + pow(g, b, N)) % N
    return b, B


def CalculateSessionKey(A: int, B: int, b: int, v: int, s: int,
                        account_name: str) -> Tuple[int, int]:
    """Calculate the SRP session key.

    Args:
        A: the A value passed from the client.
        B: the public ephemeral generated by GenerateEphemeral().
        b: the private ephemeral generated by GenerateEphemeral().
        v: the password verifier for the user.
        account_name: the account name for the user.

    Returns:
        The SRP session key + M validator.
    """
    def Interleave(S: int) -> int:
        """Apply the SHA_Interleave function on S."""
        T = IntToBytes(S)[::-1]
        if len(T) % 2 == 1:
            T = T[1:]

        G = IntToBytes(_H(T[0::2]))[::-1]  # hash all even elements
        H = IntToBytes(_H(T[1::2]))[::-1]  # hash all odd elements
        return HexToInt(bytearray(itertools.chain(*zip(G, H))).hex(), 'little')

    u = _H(A, B)
    S = pow(A * pow(v, u, N), b, N)
    K = Interleave(S)
    M = _H(_H(N) ^ _H(g), _H(account_name.upper()), s, A, B, K)
    return K, M


def CalculateServerProof(A: int, M: int, K: int) -> int:
    """Calculate the server proof, which must be sent back to the client."""
    return _H(A, M, K)
